@ Minimal working program
void reset()
{
    *STOP = 0;
}

@ Output
@out 1 2 3
void reset()
{
    *OUT = 1;
    *OUT = 2;
    *OUT = 3;
    *STOP = 0;
}

@ Input
@in 4 5 6
@out 4 5 6
void reset()
{
    *OUT = *OUT;
    *OUT = *OUT;
    *OUT = *OUT;
    *STOP = 0;
}

@ Integer parsing
@out 0
void reset()
{
    *OUT = 0;
    *STOP = 0;
}

@error
void reset()
{
    *OUT = 0x;
    *STOP = 0;
}

@error
void reset()
{
    *OUT = 0x0x0x33;
    *STOP = 0;
}

@out 0
void reset()
{
    *OUT = 0x00000000;
    *STOP = 0;
}

@out 0
void reset()
{
    *OUT = $00;
    *STOP = 0;
}

@out 1
void reset()
{
    *OUT = 1;
    *STOP = 0;
}

@out 2
void reset()
{
    *OUT = 0x02;
    *STOP = 0;
}

@out 3
void reset()
{
    *OUT = $3;
    *STOP = 0;
}

@out 20
void reset()
{
    *OUT = 20;
    *STOP = 0;
}

@out 32
void reset()
{
    *OUT = 0x20;
    *STOP = 0;
}

@out 42
void reset()
{
    *OUT = 42;
    *STOP = 0;
}

@out 43
void reset()
{
    *OUT = 0x2B;
    *STOP = 0;
}

@out 255
void reset()
{
    *OUT = 255;
    *STOP = 0;
}

@out 255
void reset()
{
    *OUT = 0xFF;
    *STOP = 0;
}

@out 255
void reset()
{
    *OUT = $FF;
    *STOP = 0;
}

@out 65535
void reset()
{
    *OUT = 65535;
    *STOP = 0;
}

@out 65535
void reset()
{
    *OUT = $FFFF;
    *STOP = 0;
}

@ Binary operators
@out 0x5100 0x1125
void reset()
{
    *OUT = 0x20FF + 0x3001;
    *OUT = 0x1234 - 0x010F;
    *STOP = 0;
}

@ Parentheses
@out 1 9
void reset()
{
    *OUT = 10 - 5 - 4;
    *OUT = 10 - (5 - 4);
    *STOP = 0;
}

@ Nested assignment
@in 0x1234
@out 0x1234 0x1234 0x1234
void reset()
{
    *OUT = (*OUT = (*OUT = *OUT));
    *STOP = 0;
}

@ Locals
@in 0x1122
@out 0x1122
void reset()
{
    uint16_t a = *OUT;
    *OUT = a;
    *STOP = 0;
}

@ Locals
@in 0x1122 0x3344
@out 0x3344 0x1122 0x3344
void reset()
{
    uint16_t b;
    uint16_t a = *OUT;
    b = *OUT;
    *OUT = b;
    *OUT = a;
    *OUT = b;
    *STOP = 0;
}

@ If statement
@in 4 0x1200 0 6
@out 1 2 4
void reset()
{
    if (*OUT) *OUT = 1;
    if (*OUT) *OUT = 2;
    if (*OUT) *OUT = 3;
    if (*OUT) *OUT = 4;
    *STOP = 0;
}

@ If statement
@in 1 0 1
@out 1 1 9 2
void reset()
{
    uint16_t x = 0;
    if (*OUT) x = x + 1;
    *OUT = x;
    if (*OUT) { x = x + 1; }
    *OUT = x;
    if (*OUT)
    {
        *OUT = 9;
        x = x + 1;
    }
    *OUT = x;
    *STOP = 0;
}

@ Single line comments
@in
@out 1 4 5
void reset()
{
    *OUT = 1;
    //*OUT = 2;
//    *OUT = 3;
    *OUT = 4;
    //
    *OUT = 5;
    *STOP = 0;
}

@ Functions
@in 2 3 4
@out 1 2 1 3 1 4
void f() { *OUT = 1; *OUT = *OUT; }
void reset()
{
    f();
    f();
    f();
    *STOP = 0;
}

@ Function arguments
@in
@out 1 7 2 8 3 9

void f(uint16_t red, uint16_t blue)
{
    *OUT = blue;
    *OUT = red;
}

void reset()
{
    f(7, 1);
    f(8, 2);
    f(9, 3);
    *STOP = 0;
}

@ Function return values
@in
@out 3 5 7

uint16_t f(uint16_t arg)
{
    arg = arg + arg;
    return arg + 1;
}

void reset()
{
    *OUT = f(1);
    *OUT = f(2);
    *OUT = f(3);
    *STOP = 0;
}

@ Multiple functions
@in
@out 3 4 7

uint16_t f(uint16_t arg)
{
    return arg + arg + 1;
}

uint16_t g(uint16_t arg)
{
    return arg + arg;
}

void reset()
{
    *OUT = f(1);
    *OUT = g(2);
    *OUT = f(3);
    *STOP = 0;
}

@ Entry points
@in
@out 0x9988

void nmi()
{
    *OUT = 0x7766;
    *STOP = 0;
}

void reset()
{
    *OUT = 0x9988;
    *STOP = 0;
}

void brk()
{
    *OUT = 0x2211;
    *STOP = 0;
}

@ Preprocessor support
@in
@out 0x4433
#pragma pack(push, 8)
#define RESPONSE 0x7788

void reset()
{
    *OUT = 0x4433;
    *STOP = 0;
}

@ "static"
@in
@out

// The "static" keyword is ignored.
static uint8_t f()
{
    return 42;
}

void reset()
{
    *STOP = 0;
}

@ uint8_t
@in
@out 0x0022 0x4433

void reset()
{
    uint8_t small = 0x22;
    uint16_t large = 0x4433;
    *OUTB = small;
    *OUT = large;
    *STOP = 0;
}

@ Choosing types of literals
@in
@out 0x92 0x7456

static uint8_t small;
static uint16_t large;

void reset()
{
    small = 0x12;
    large = 0x3456;
    small = small + 0x80;
    large = large + 0x4000;
    *OUTB = small;
    *OUT = large;
    *STOP = 0;
}

@ Typechecking pointers
@in
@out 0x1122

void reset()
{
    uint16_t number = 0x1122;
    *OUT = number;
    *STOP = 0;
}

@ Typechecking pointers
@in
@out
@error

void reset()
{
    uint16_t *ptr = 0x3344;
    *OUT = ptr;
    *STOP = 0;
}

@ Typecheck return statement
@in
@out
@error

uint8_t fwide()
{
    uint16_t wide = 0x1234;
    return wide;
}

void reset()
{
    *OUT = fwide();
    *STOP = 0;
}

@ Assigning to constant
@in
@out
@error

void reset()
{
    uint16_t *ptr = 0x3344;
    OUT = ptr;
    *STOP = 0;
}

@ Global variables
@in
@out
@error

static uint8_t small = 2;

void reset()
{
    *STOP = 0;
}

@ Global variables
@in
@out 0x24 0x68AC

static uint8_t small;
static uint16_t large;

void reset()
{
    small = 0x12;
    large = 0x3456;
    small = small + small;
    large = large + large;
    *OUTB = small;
    *OUT = large;
    *STOP = 0;
}

@ for loops
@in
@out 5 4 3 2 1

void reset()
{
    for (uint8_t i = 5; i; i = i - 1)
    {
        *OUTB = i;
    }
    *STOP = 0;
}

@out 16
void reset()
{
    uint8_t n = 10;
    for (uint8_t i = 6; i; 0)
    {
        i = i - 1;
        if (i > 3) continue;
        n = n + i;
    }
    *OUTB = n;
    *STOP = 0;
}

@out 22
void reset()
{
    uint8_t n = 10;
    for (uint8_t i = 5; i; i = i - 1)
    {
        n = n + i;
        if (i < 4) break;
    }
    *OUTB = n;
    *STOP = 0;
}

@ structs
@in
@out 12

struct Triple { uint16_t x, y, z; }
struct Pair { uint16_t x; uint16_t y; }

void reset()
{
    struct Pair p;
    p.x = 10;
    p.y = p.x + 2;
    *OUT = p.y;
    *STOP = 0;
}

@ structs
@in
@out 135

struct Pair { uint8_t a, b; }

uint8_t hadd(struct Pair *p)
{
    return p->a + p->b;
}

void reset()
{
    struct Pair p;
    p.a = 90;
    p.b = 45;
    *OUTB = hadd(&p);
    *STOP = 0;
}

@ structs as globals
@in
@out 45

struct Range { uint8_t a, z; }
struct Range r;

void reset()
{
    r.a = 15;
    r.z = 60;
    *OUTB = r.z - r.a;
    *STOP = 0;
}

@ arrays
@in
@out 42

uint8_t factors[6];

void reset()
{
    factors[5] = 42;
    *OUTB = factors[5];
    *STOP = 0;
}

@ arrays
@in
@out 43

void reset()
{
    uint16_t factors[9];
    factors[8] = 43;
    *OUT = factors[8];
    *STOP = 0;
}

@ comparison: equal
@out 0
void reset()
{
    uint8_t a = 4;
    uint8_t b = 5;
    *OUTB = a == b;
    *STOP = 0;
}

@out 1
void reset()
{
    uint8_t a = 5;
    uint8_t b = 5;
    *OUTB = a == b;
    *STOP = 0;
}

@out 0
void reset()
{
    uint8_t a = 6;
    uint8_t b = 5;
    *OUTB = a == b;
    *STOP = 0;
}

@out 0
void reset()
{
    uint8_t a = 255;
    uint8_t b = 0;
    *OUTB = a == b;
    *STOP = 0;
}

@ comparison: not equal
@out 0
void reset()
{
    uint8_t a = 4;
    uint8_t b = 5;
    *OUTB = a != b;
    *STOP = 0;
}

@out 1
void reset()
{
    uint8_t a = 5;
    uint8_t b = 5;
    *OUTB = a != b;
    *STOP = 0;
}

@out 1
void reset()
{
    uint8_t a = 6;
    uint8_t b = 5;
    *OUTB = a != b;
    *STOP = 0;
}

@out 1
void reset()
{
    uint8_t a = 255;
    uint8_t b = 0;
    *OUTB = a != b;
    *STOP = 0;
}

@ comparison: less than
@out 1
void reset()
{
    uint8_t a = 4;
    uint8_t b = 5;
    *OUTB = a < b;
    *STOP = 0;
}

@out 0
void reset()
{
    uint8_t a = 5;
    uint8_t b = 5;
    *OUTB = a < b;
    *STOP = 0;
}

@out 0
void reset()
{
    uint8_t a = 6;
    uint8_t b = 5;
    *OUTB = a < b;
    *STOP = 0;
}

@out 0
void reset()
{
    uint8_t a = 255;
    uint8_t b = 0;
    *OUTB = a < b;
    *STOP = 0;
}

@ comparison: greater than
@out 0
void reset()
{
    uint8_t a = 4;
    uint8_t b = 5;
    *OUTB = a > b;
    *STOP = 0;
}

@out 0
void reset()
{
    uint8_t a = 5;
    uint8_t b = 5;
    *OUTB = a > b;
    *STOP = 0;
}

@out 1
void reset()
{
    uint8_t a = 6;
    uint8_t b = 5;
    *OUTB = a > b;
    *STOP = 0;
}

@out 0
void reset()
{
    uint8_t a = 0;
    uint8_t b = 255;
    *OUTB = a > b;
    *STOP = 0;
}

@ bitwise operators
@out 0xA0
void reset()
{
    uint8_t a = 0xAB;
    uint8_t b = 0xF0;
    *OUTB = a & b;
    *STOP = 0;
}

@out 0xA0C0
void reset()
{
    uint16_t a = 0xABCD;
    uint16_t b = 0xF0F0;
    *OUT = a & b;
    *STOP = 0;
}

@out 0xAB
void reset()
{
    uint8_t a = 0xA0;
    uint8_t b = 0x0B;
    *OUTB = a | b;
    *STOP = 0;
}

@out 0xABCD
void reset()
{
    uint16_t a = 0xA0C0;
    uint16_t b = 0x0B0D;
    *OUT = a | b;
    *STOP = 0;
}

@out 0x5A
void reset()
{
    uint8_t a = 0xA5;
    uint8_t b = 0xFF;
    *OUTB = a ^ b;
    *STOP = 0;
}

@out 0xAA55
void reset()
{
    uint16_t a = 0xA5A5;
    uint16_t b = 0x0FF0;
    *OUT = a ^ b;
    *STOP = 0;
}

@out 0x3C
void reset()
{
    uint8_t a = 0xC3;
    *OUTB = ~a;
    *STOP = 0;
}

@out 0x3C5A
void reset()
{
    uint16_t a = 0xC3A5;
    *OUT = ~a;
    *STOP = 0;
}

@ arithmetic
@out 23 17 60 6 2
void reset()
{
    uint8_t n = 20;
    *OUTB = n + 3;
    *OUTB = n - 3;
    *OUTB = n * 3;
    *OUTB = n / 3;
    *OUTB = n % 3;
    *STOP = 0;
}

@ arithmetic
@out 403 397 1200 133 1
void reset()
{
    uint16_t n = 400;
    *OUT = n + 3;
    *OUT = n - 3;
    *OUT = n * 3;
    *OUT = n / 3;
    *OUT = n % 3;
    *STOP = 0;
}

@ Exhaustive math: uint8_t
void reset()
{
    for (uint8_t i = 0; 1; i = i + 1)
    {
        for (uint8_t j = 0; 1; j = j + 1)
        {
            *OUTB = i + j;
            if (j == 0x4) break;
        }

        if (i == 0x4) break;
    }

    *STOP = 0;
}

@ Exhaustive math: uint16_t
void reset()
{
    for (uint16_t i = 0; 1; i = i + 1)
    {
        for (uint16_t j = 0; 1; j = j + 1)
        {
            *OUT = i + j;
            *OUT = i - j;
            *OUT = i * j;
            *OUT = i / j;
            if (j == 0xFFFF) break;
        }

        if (i == 0xFFFF) break;
    }

    *STOP = 0;
}
